---
title: Do you have too many collections?
sidebar_label: Scaling limits with collections
sidebar_position: 1
image: og/docs/more-resources.jpg
# tags: ['performance']
---

:::caution
If you see an error that the collection count limit has been reached, it means the overhead from maintaining many separate collections is affecting performance. This limit exists to control indexing, storage, and management complexity.

<br />

**Instead of simply raising the limit, consider rethinking your architecture**. If you really need to change the limit, use the [`MAXIMUM_ALLOWED_COLLECTIONS_COUNT`](/developers/weaviate/config-refs/env-vars) environment variable.
:::

This guide offers an overview of the available architectural choices of using multi-tenancy or defining a dedicated collection for each tenant.

Consider a scenario where you are developing a SaaS platform for product recommendations, allowing merchants to import and vectorize their product data. The users of this platform, merchants, require the ability to efficiently perform vector searches to generate personalized recommendations for users on their respective e-commerce platforms.

One option is creating a dedicated collection for each merchant to store their product data. However, as the number of merchants grows, so does the number of collections, potentially leading to performance bottlenecks and increased operational complexity. This leads us to an important question: **How many collections is too many?**

## Structuring the data in a vector database

import MultiTenanyVsMultipleCollections from '/developers/weaviate/starter-guides/img/weaviate-multi-tenancy-vs-multiple-collections.png';

<div class="row">
  <div class="card">
    <div class="card__image">
      <img
        src={MultiTenanyVsMultipleCollections}
        alt='Multi-tenancy vs "One collection per tenant" architecture'
      />
    </div>
  </div>
</div>
<br />

When designing a vector database collection definition (data schema), you must decide between **multi-tenancy** (storing data for multiple tenants in a single collection) or creating **separate collections for each tenant** (the "One collection per tenant" strategy). Each approach has its own advantages and trade-offs, especially in terms of performance, scalability, and management.

This guide aims to clarify these concepts and highlight the implications of each approach, focusing on the benefits and drawbacks:

- **["One collection per tenant" architecture](#one-collection-per-tenant-architecture)**
- **[Multi-tenancy architecture](#multi-tenancy-architecture)**

### "One collection per tenant" architecture

In this approach, **each tenant is assigned a dedicated collection** to ensure the separation of data between them. Before the implementation of multi-tenancy in Weaviate this was the best approach for managing data for multiple tenants.

import MultipleCollectionsExample from '/developers/weaviate/starter-guides/img/weaviate-multiple-collections-example.png';

<div class="row">
  <div class="col col--4">
    <p>
      When a "book store" registers on our platform, we create the collection{' '}
      <code>BookStoreProducts</code> for that merchant's products. This allows
      them to customize the collection and add properties that are specific to
      their e-commerce platform, like author, title, genre, etc.
      <br />
      <br />
      Creating a new collection per merchant (<code>ShoeStoreProducts</code>, <code>
        GameStoreProduct
      </code>, etc.) might seem like a simple and effective way to maintain data
      isolation. However, as the platform scales, this approach quickly encounters
      significant challenges.
    </p>
  </div>
  <div class="col col--8">
    <div class="card">
      <div class="card__image">
        <img
          src={MultipleCollectionsExample}
          alt='"One collection per tenant" architecture example'
        />
      </div>
      <div class="card__body">
        "One collection per tenant" architecture example.
      </div>
    </div>
  </div>
</div>
<br />

#### Advantages

- **Customizability**: Schema changes or optimizations can be tailored to individual collections without affecting others.
- **Simpler queries**: Queries do not require tenant-specific filters, as each collection inherently belongs to a single tenant.
- **Data isolation**: In theory, each tenant’s data is completely segregated through the use of separate collections.

#### Challenges

- **Resource overhead:** Each collection requires its own schema, indexes, and storage, leading to increased memory and disk usage. Managing thousands or even millions of collections becomes nearly impossible.
- **Operational complexity:** Schema changes must be applied individually to each collection. If a new feature requires modifying the schema (e.g., adding a `release_date` property), every collection must be updated separately and this takes a lot of time and computational effort.
- **Query performance:** Retrieving data across multiple collections can be inefficient, especially when performing global analytics (e.g., searching throughout multiple collections).
- **Scaling limits:** Weaviate performs best when managing a limited number of collections. Exceeding a few hundred collections can introduce significant strain on the system, affecting indexing, backups, and restores.

:::tip
If you are creating more than 10 collections, take a moment to consider if multi-tenancy might be utilized.
:::

### Multi-tenancy architecture

Multi-tenancy refers to the practice of using a single collection to store data for multiple tenants. Each tenant’s data is logically isolated through the use of metadata fields like tenant names. Multi-tenancy is especially useful when you want to store data for multiple customers or when you want to store similarly structured data for multiple projects.

import MultiTenancyExample from '/developers/weaviate/starter-guides/img/weaviate-multi-tenancy-example.png';

<div class="row">
  <div class="col col--4">
    <br />
    <p>
      Each merchant is identified by their name, ensuring that their products
      remain logically separated within the same collection. When a "book store"
      registers on our platform, we can create a new tenant called{' '}
      <code>BookStore</code> in the collection <code>Products</code>.
      <br />
      <br />
      Queries can also be filtered based on the name to retrieve only the relevant
      data.
    </p>
  </div>
  <div class="col col--8">
    <div class="card">
      <div class="card__image">
        <img
          src={MultiTenancyExample}
          alt="Multi-tenancy architecture example"
        />
      </div>
      <div class="card__body">Multi-tenancy architecture example.</div>
    </div>
  </div>
</div>
<br />

#### Advantages

Use multi-tenancy when you need to support a large number of tenants and prioritize resource efficiency and scalability.

- **Efficient resource utilization:** A single collection reduces indexing overhead and simplifies schema management.
- **Easier schema management:** Schema updates apply universally to all merchants. For example, adding a new property to all products is now much easier.
- **Optimized query performance:** Queries can leverage the tenant name to retrieve only the relevant products. You also don't have to keep track of what collections are associated with what merchants.
- **Scalability**: Indexes can be optimized with a single collection in mind rather than being fragmented across multiple collections. Each tenant has a dedicated, high-performance vector index which results in faster query speeds. Instead of searching a shared index space, each tenant responds as if it were the only user on the cluster.
- **Data isolation**: Each tenant’s data is completely segregated, simplifying access control and compliance requirements. This also means that data deletion is much easier and faster.

#### Challenges

- **Access control complexity**: [Fine-grained access control](/developers/weaviate/configuration/authorization) must be implemented to ensure data isolation between tenants.

:::tip Reduce storage costs
You can change the [state of a tenant](/developers/weaviate/starter-guides/managing-resources/tenant-states) into `inactive` (stored locally on disk) or `offloaded` (stored on cloud storage) in order to save resources.

<br />

Find out more about managing multi-tenancy in [How to: Multi-tenancy operations](/developers/weaviate/manage-data/multi-tenancy).
:::

<!--
## Conclusion

The choice between multi-tenancy and multiple collections depends on your specific use case, including the number of tenants, query patterns, and performance requirements. While multi-tenancy offers scalability and resource efficiency, multiple collections provide stronger data isolation and flexibility. Regularly monitor query performance, index size, and resource utilization to adjust the architecture as needed. Understanding the trade-offs will help you design an architecture that meets both current and future needs.
-->

## Additional resources

To find out more about multi-tenancy, visit the following pages:

- [How-to: Multi-tenancy operations](/developers/weaviate/manage-data/multi-tenancy)
- [How-to: Manage tenant states](/developers/weaviate/manage-data/tenant-states)

## Questions and feedback

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback />
