---
title: Build an E-Commerce assistant with Query Agents
sidebar_label: E-Commerce assistant with Query Agents
description: Learn how to build a simple e-commerce assistant agent with the Weaviate Query Agent.
sidebar_position: 1
image: og/docs/tutorials.jpg
# tags: ['basics']
---

In this tutorial, we will be building a simple e-commerce assistant agent with the **[Weaviate Query Agent](developers/agents/query.md)**. This agent will have access to a number of Weaviate collections, and will be capable of answering complex queries about brands and clothing items, accessing information from each collection.

import WeaviateAgentsECommerceFlowchart from '/developers/weaviate/tutorials/img/weaviate-agents-ecommerce-flowchart.png';

<div class="row">
  <div class="card">
    <div class="card__image">
      <img
        src={WeaviateAgentsECommerceFlowchart}
        alt="Weaviate Query Agent flowchart"
      />
    </div>
  </div>
</div>
<br />

The Query Agent works like this:
1. **Give the Query Agent a task** in the form of a question or instructions.
2. The Query Agent uses an appropriate **foundation model** (e.g. large language model) to analyze the task and determine the exact queries to perform. 
3. The Query Agent **sends the queries to Weaviate**. Weaviate vectorizes the queries as needed using the specified vectorizer integration (we will use Weaviate Embeddings).
4. The Query Agent **receives the results from Weaviate** and uses appropriate foundation models to generate the final response to the user prompt/query. 

We've prepared a few public datasets that you can use to explore the Query Agent.  
They are available on HuggingFace:

- [**E-commerce:**](https://huggingface.co/datasets/weaviate/agents/viewer/query-agent-ecommerce) A dataset that lists clothing items, prices, brands, reviews, etc.
- [**Brands:**](https://huggingface.co/datasets/weaviate/agents/viewer/query-agent-brands) A dataset that lists clothing brands and information about them, such as their parent brand, child brands, average customer rating, etc.

Now let's get started by setting up a Weaviate Cloud instance that we will use for this tutorial and connecting to it with the Python client.

## Prerequisites

To use the Weaviate Query Agent and Weaviate Embedding service, you need to have a **[Weaviate Cloud](https://console.weaviate.cloud)** account.

## Step 1: Set up Weaviate

### 1.1 Create a Weaviate Cloud cluster

1. Create a [free Sandbox cluster](/developers/wcs/manage-clusters/create#sandbox-clusters) in Weaviate Cloud.
1. Take note of the `REST Endpoint` and `Admin` API key to connect to your cluster. (for more info check out the [quickstart](/developers/wcs/quickstart#22-connect-to-your-weaviate-cloud-instance))

:::tip
In this tutorial, we are using the [Weaviate Embeddings](https://weaviate.io/developers/weaviate/model-providers/weaviate) service as the vectorizer, so you do not have to provide any extra keys for external embedding providers.

Weaviate Embeddings uses the `Snowflake/snowflake-arctic-embed-l-v2.0` as the default embedding model.
:::

### 1.2 Install the Python libraries

In order to install the Weaviate Python client together with the `agents` component run:

```
!pip install git+https://github.com/weaviate/weaviate-python-client.git@weaviate-agents-integration#egg=weaviate-client[agents]
```

You will also need `datasets`, a lightweight library providing access to the publicly hosted datasets on HuggingFace.

```
!pip install datasets
```

### 1.3 Connect to your instance

Now you can finally connect to your Weaviate Cloud instance with the parameters from the first step:

```python
import os
import weaviate
from weaviate.auth import Auth

# Best practice: store your credentials in environment variables
weaviate_url = os.environ["WEAVIATE_URL"]
weaviate_api_key = os.environ["WEAVIATE_API_KEY"]

client = weaviate.connect_to_weaviate_cloud(
        cluster_url=weaviate_url,
        auth_credentials=Auth.api_key(weaviate_api_key),
)

print(client.is_ready())  # Should print: `True`

# Your work goes here!

client.close()  # Free up resources
```

After running this snipet, you should see the message `True` printed out which means that your have successfully connected to your instance.

## Step 2: Prepare the Collections

Before we can start importing the data into Weaviate, we need to **define the collections** which means setting up the data schema and choosing the vectorizer/embedding service.

### 2.1 Define the Collections

Below you can see what the objects in the datasets `eCommerce` and `Brands` look like. 

import WeaviateAgentsEcommerceDataset from '/developers/weaviate/tutorials/img/weaviate-agents-ecommerce-dataset.png';

<div class="row">
  <div class="card">
    <div class="card__image">
      <img
        src={WeaviateAgentsEcommerceDataset}
        alt="The eCommerce and Brands datasets"
      />
    </div>
  </div>
</div>
<br />

In the following code blocks, we are pulling our demo datasets from Hugging Face and writing them to new collections in our Weaviate Serverless cluster.

:::tip
The `QueryAgent` uses the descriptions of collections and properties to decide which ones to use when solving queries, and to access more information about properties. You can experiment with changing these descriptions, providing more detail, and more. It's good practice to provide property descriptions too. For example, below we make sure that the `QueryAgent` knows that prices are all in USD, which is information that would otherwise be unavailable.
:::

```python
from weaviate.classes.config import Configure, Property, DataType

client.collections.delete_all()
client.collections.create(
    "Brands",
    description="A dataset that lists information about clothing brands, their parent companies, average rating and more.",
    vectorizer_config=Configure.Vectorizer.text2vec_weaviate()
    )

client.collections.create(
    "ecommerce",
    description="A dataset that lists clothing items, their brands, prices, and more.",
    vectorizer_config=Configure.Vectorizer.text2vec_weaviate(),
    properties=[
        Property(name="collection", data_type=DataType.TEXT),
        Property(name="category", data_type=DataType.TEXT),
        Property(name="tags", data_type=DataType.TEXT_ARRAY),
        Property(name="subcategory", data_type=DataType.TEXT),
        Property(name="name", data_type=DataType.TEXT),
        Property(name="description", data_type=DataType.TEXT),
        Property(name="brand", data_type=DataType.TEXT),
        Property(name="product_id", data_type=DataType.UUID),
        Property(name="colors", data_type=DataType.TEXT_ARRAY),
        Property(name="reviews", data_type=DataType.TEXT_ARRAY),
        Property(name="image_url", data_type=DataType.TEXT),
        Property(name="price", data_type=DataType.NUMBER, description="price of item in USD"),
    ]
    )
```

### 2.2 Populate the database

Now we can import the data into our Weaviate Cloud instance:

```python
from datasets import load_dataset
from datetime import datetime, timezone

brands_dataset = load_dataset("weaviate/agents", "query-agent-brands", split="train", streaming=True)
ecommerce_dataset = load_dataset("weaviate/agents", "query-agent-ecommerce", split="train", streaming=True)

brands_collection = client.collections.get("Brands")
ecommerce_collection = client.collections.get("ecommerce")

with brands_collection.batch.dynamic() as batch:
  for item in brands_dataset:
      batch.add_object(properties=item["properties"])

with ecommerce_collection.batch.dynamic() as batch:
  for item in ecommerce_dataset:
      batch.add_object(properties=item["properties"])

print(f"Size of the eCommerce dataset: {len(ecommerce_collection)}")
print(f"Size of the Brands dataset: {len(brands_collection)}")
```

By calling `len()` on our collections we can check that import has successfully concluded and see what the size of our collections is. 

## Step 3: Set up the Query Agent

When setting up the query agent, we have to provide a few things:

- The `client`
- The `collection` which we want the agent to have access to.
- (Optionally) A `system_prompt` that describes how our agent should behave
- (Optionally) Timeout - which for now defaults to 60s.

Let's start with a simple agent. Here, we're creating an `agent` that has access to our `brands` and `ecommerce` datasets.

```python
from weaviate.agents.query import QueryAgent

agent = QueryAgent(
    client=client, collections=["ecommerce", "Brands"],
)
```

And that's about it! Now you can start using the Query Agent. 

## Step 4: Run the Query Agent

When we run the agent, it will first make a few decisions, depending on the query:

1. The agent will decide which collection or collections to look up an answer in.
2. The agent will also decide whether to perform a regular **_search query_**, what **_filters_** to use, whether to do an **_aggregation query_**, or all of them together!
3. It will then provide a reponse within **`QueryAgentResponse`**.

### 4.1 Ask a question

**Let's start with a simple question: "I like the vintage clothes, can you list me some options that are less than $200?"**

We can then also inspect how the agent responded, what kind of searches it performed on which collections, whether it has identified if the final answer is missing information or not, as well as the final answer ðŸ‘‡

```python
from weaviate.agents.utils import print_query_agent_response

response = agent.run("I like the vintage clothes, can you list me some options that are less than $200?")
print_query_agent_response(response)
```

### 4.2 Ask a follow up question

The agent can also be provided with additional context. For example, we can provide the previous response as context and get a `new_response`

```python
new_response = agent.run("What about some nice shoes, same budget as before?", context=response)
print_query_agent_response(new_response)
```

Now let's try a question that sholud require an aggregation. Let's see which brand lists the most shoes.

```python
response = agent.run("What is the the name of the brand that lists the most shoes?")
print_query_agent_response(response)
```

### 4.3 Search over multiple collections

In some cases, we need to combine the results of searches across multiple collections. From the result above, we can see that "Loom & Aura" lists the most shoes.

Let's imagine a scenario where the user would now want to find out more about this company, _as well_ as the items that they sell.

```python
response = agent.run("Does the brand 'Loom & Aura' have a parent brand or child brands and what countries do they operate from? "
                     "Also, what's the average price of a shoe from 'Loom & Aura'?")

print_query_agent_response(response)
```

### 4.4 Changing the system prompt

In some cases, you may want to define a custom `system_prompt` for your agent. This can help you provide the agent with some default instructions as to how to behave. For example, let's create an agent that will always answer the query in the users language.

```python
multi_lingual_agent = QueryAgent(
    client=client, collections=["ecommerce", "Brands"],
    system_prompt="You are a helpful assistant that always generated the final response in the users language."
    " You may have to translate the user query to perform searches. But you must always respond to the user in their own language."
)
```

For example, this time lets ask something that is about weather!
TODO

### 4.5 Try more Questions

- For example Let's try to find out more about the brans "Eko & Stitch"

```python
response = agent.run("Does Eko & Stitch have a branch in the UK? Or if not, does it have parent or child company in the UK?")

print(response.final_answer)
```

## Summary

## Further resources
